//! Parsing functions, from text to [commands](Command).

use core::result;

use elaboration::builder::{declaration, level, term};
use elaboration::location::Location;
use pest::iterators::Pair;
use pest::{Parser, Span};

use crate::command::Command;
use crate::error::{Error, Kind, Result};

/// Parser structure generated by Pest
#[derive(Parser)]
#[grammar = "command/grammar.pest"]
struct CommandParser;

/// Converts pest [`Span`] to our [location](elaboration::location::Location).
fn convert_span(span: Span) -> Location {
    let (x1, y1) = span.start_pos().line_col();
    let (x2, y2) = span.end_pos().line_col();

    Location::new((x1, y1), (x2, y2))
}

/// Builds [`kernel`] [levels](level::Builder) from errorless pest output
fn parse_level(pair: Pair<Rule>) -> Result<level::Builder> {
    use level::Builder::{Const, IMax, Max, Plus, Var};

    match pair.as_rule() {
        Rule::Num => {
            let pos = pair.as_span();

            pair.into_inner().as_str().parse().map(Const).map_err(|err| Error {
                location: convert_span(pos),
                kind: Kind::TransformError(err.to_string()),
            })
        },

        Rule::Max => {
            let mut iter = pair.into_inner();
            let univ1 = parse_level(iter.next().unwrap())?;
            let univ2 = parse_level(iter.next().unwrap())?;

            Ok(Max(box univ1, box univ2))
        },

        Rule::IMax => {
            let mut iter = pair.into_inner();
            let univ1 = parse_level(iter.next().unwrap())?;
            let univ2 = parse_level(iter.next().unwrap())?;

            Ok(IMax(box univ1, box univ2))
        },

        Rule::Plus => {
            let mut iter = pair.into_inner();
            let univ = parse_level(iter.next().unwrap())?;

            let numbers = iter.map(|pair| {
                pair.as_str().parse::<usize>().map_err(|err| Error {
                    location: convert_span(pair.as_span()),
                    kind: Kind::TransformError(err.to_string()),
                })
            });

            numbers.into_iter().try_fold(univ, |acc, u| u.map(|u| Plus(box acc, u)))
        },

        Rule::string => Ok(Var(pair.as_str())),

        univ => unreachable!("unexpected universe level: {univ:?}"),
    }
}

/// Builds [`kernel`] [terms](term::Builder) from errorless pest output
fn parse_term(pair: Pair<Rule>) -> Result<term::Builder> {
    use term::Builder;
    use term::Payload::{Abs, App, Prod, Prop, Sort, Type, Var, VarInstance};

    let loc = convert_span(pair.as_span());

    match pair.as_rule() {
        Rule::Prop => Ok(Builder::new(loc, Prop)),

        Rule::Var => Ok(Builder::new(loc, Var(pair.into_inner().as_str()))),

        Rule::VarDecl => {
            let mut iter = pair.into_inner();
            let name = iter.next().unwrap().as_str();
            let levels = iter.next().unwrap().into_inner().map(parse_level).collect::<result::Result<_, _>>()?;

            Ok(Builder::new(loc, VarInstance(name, levels)))
        },

        Rule::Type => pair.into_inner().next_back().map_or_else(
            || Ok(Builder::new(loc, Type(box level::Builder::Const(0)))),
            |next| Ok(Builder::new(loc, Type(box parse_level(next)?))),
        ),

        Rule::Sort => pair.into_inner().next_back().map_or_else(
            || Ok(Builder::new(loc, Sort(box level::Builder::Const(0)))),
            |next| Ok(Builder::new(loc, Sort(box parse_level(next)?))),
        ),

        Rule::App => {
            let mut iter = pair.into_inner().map(parse_term);
            let term = iter.next().unwrap()?;

            iter.try_fold(term, |acc, x| x.map(|x| Builder::new(loc, App(box acc, box x))))
        },

        Rule::Abs => {
            let mut iter = pair.into_inner();
            let body = parse_term(iter.next_back().unwrap())?;

            iter.flat_map(|pair| {
                let mut pair = pair.into_inner();
                let type_ = parse_term(pair.next_back().unwrap());

                pair.map(move |var| (var.as_str(), type_.clone()))
            })
            .rev()
            .try_fold(body, |acc, (var, type_)| type_.map(|type_| Builder::new(loc, Abs(var, box type_, box acc))))
        },

        Rule::dProd => {
            let mut iter = pair.into_inner();
            let body = parse_term(iter.next_back().unwrap())?;

            iter.flat_map(|pair| {
                let mut pair = pair.into_inner();
                let type_ = parse_term(pair.next_back().unwrap());

                pair.map(move |var| (var.as_str(), type_.clone()))
            })
            .rev()
            .try_fold(body, |acc, (var, type_)| type_.map(|type_| Builder::new(loc, Prod(var, box type_, box acc))))
        },

        Rule::Prod => {
            let mut iter = pair.into_inner();
            let ret = parse_term(iter.next_back().unwrap())?;

            iter.map(parse_term)
                .rev()
                .try_fold(ret, |acc, argtype| argtype.map(|argtype| Builder::new(loc, Prod("_", box argtype, box acc))))
        },

        term => unreachable!("unexpected term: {term:?}"),
    }
}

fn parse_args(pair: Pair<Rule>) -> Result<Vec<(String,term::Builder)>> {
    match pair.as_rule() {
        Rule::Args => {
        }
    }
}

/// Builds a command from errorless pest output
fn parse_expr(pair: Pair<Rule>) -> Result<Command> {
    match pair.as_rule() {
        Rule::GetType => {
            let mut iter = pair.into_inner();
            let t = parse_term(iter.next().unwrap())?;

            Ok(Command::GetType(t))
        },

        Rule::CheckType => {
            let mut iter = pair.into_inner();
            let t1 = parse_term(iter.next().unwrap())?;
            let t2 = parse_term(iter.next().unwrap())?;

            Ok(Command::CheckType(t1, t2))
        },

        Rule::Define => {
            let mut iter = pair.into_inner();
            let s = iter.next().unwrap();
            let args = parse_args(iter.next());
            let term = parse_term(iter.next().unwrap())?;

            Ok(Command::Define((convert_span(s.as_span()), s.as_str()), None, term))
        },

        Rule::DefineCheckType => {
            let mut iter = pair.into_inner();
            let s = iter.next().unwrap();
            let args = parse_args(iter.next());
            let ty = parse_term(iter.next().unwrap())?;
            let term = parse_term(iter.next().unwrap())?;

            Ok(Command::Define((convert_span(s.as_span()), s.as_str()), Some(ty), term))
        },

        Rule::Declaration => {
            let mut iter = pair.into_inner();
            let mut string_decl = iter.next().unwrap().into_inner();
            let s = string_decl.next().unwrap();
            let vars: Vec<&str> = string_decl.next().unwrap().into_inner().map(|name| name.as_str()).collect();
            let args = parse_args(iter.next());
            let body = iter.next().map(parse_term).unwrap()?;

            Ok(Command::Declaration((convert_span(s.as_span()), s.as_str()), None, declaration::Builder::Decl(box body, vars)))
        },

        Rule::DeclarationCheckType => {
            let mut iter = pair.into_inner();
            let mut string_decl = iter.next().unwrap().into_inner();
            let s = string_decl.next().unwrap();
            let vars: Vec<&str> = string_decl.next().unwrap().into_inner().map(|name| name.as_str()).collect();

            let args = parse_args(iter.next());
            let ty = parse_term(iter.next().unwrap())?;
            let decl = iter.next().map(parse_term).unwrap()?;

            let ty = declaration::Builder::Decl(box ty, vars.clone());
            let decl = declaration::Builder::Decl(box decl, vars);

            Ok(Command::Declaration((convert_span(s.as_span()), s.as_str()), Some(ty), decl))
        },

        Rule::Eval => {
            let term = parse_term(pair.into_inner().next().unwrap())?;

            Ok(Command::Eval(term))
        },

        Rule::ImportFile => {
            let files = pair.into_inner().map(|pair| (convert_span(pair.as_span()), pair.as_str())).collect();

            Ok(Command::Import(files))
        },

        Rule::Search => {
            let s = pair.into_inner().next().unwrap().as_str();

            Ok(Command::Search(s))
        },

        command => unreachable!("Unexpected command: {:?}", command),
    }
}

/// Parse a text input and try to convert it into a command.
///
/// # Errors
/// If unsuccessful, the first error that was encountered is returned.
#[inline]
pub fn line(line: &str) -> Result<Command> {
    CommandParser::parse(Rule::command, line)
        .map_err(std::convert::Into::into)
        .and_then(|mut pairs| parse_expr(pairs.next().unwrap_or_else(|| unreachable!())))
}

/// Parse a text input and try to convert it into a vector of commands.
///
/// # Errors
/// If unsuccessful, the first error that was encountered is returned.
#[inline]
pub fn file(file: &str) -> Result<Vec<Command>> {
    CommandParser::parse(Rule::file, file)
        .map_err(std::convert::Into::into)
        .and_then(|pairs| pairs.into_iter().map(parse_expr).collect())
}

#[cfg(test)]
mod tests {
    use term::Builder;
    use term::Payload::*;

    use super::Command::*;
    use super::*;

    /// Error messages
    const COMMAND_ERR: &str = "expected def var := term, def var : term := term, def decl.{ vars, ... } := term, def decl.{ vars, ... } : term := term, check term : term, check term, eval term, import path_to_file, or search var";
    const SIMPLE_TERM_ERR: &str = "expected variable, abstraction, Prop, Type, Sort, or universe argument";
    const TERM_ERR: &str = "expected variable, abstraction, dependent product, application, product, Prop, Type, or Sort";
    const TOO_LARGE_NUMBER: &str = "number too large to fit in target type";
    const UNIVERSE_ERR: &str = "expected number, variable, abstraction, Prop, Type, Sort, plus, max, or imax";

    #[test]
    fn failure_universe_level() {
        assert_eq!(
            line("check fun x : Prop -> Type"),
            Err(Error {
                kind: Kind::UnexpectedToken(UNIVERSE_ERR.to_owned()),
                location: Location::new((1, 27), (1, 28)),
            })
        );
    }

    #[test]
    fn successful_define_with_type_annotation() {
        assert_eq!(
            line("def x : Type := Prop"),
            Ok(Define(
                (Location::new((1, 5), (1, 6)), "x"),
                Some(Builder::new(Location::new((1, 9), (1, 14)), Type(box level::Builder::Const(0)))),
                Builder::new(Location::new((1, 17), (1, 21)), Prop)
            ))
        );
    }

    #[test]
    fn successful_declare_with_type_annotation() {
        assert_eq!(
            line("def x.{u} : Type u := foo.{u}"),
            Ok(Declaration(
                (Location::new((1, 5), (1, 6)), "x"),
                Some(declaration::Builder::Decl(
                    box Builder::new(Location::new((1, 13), (1, 19)), Type(box level::Builder::Var("u"))),
                    vec!["u"]
                )),
                declaration::Builder::Decl(
                    box Builder::new(Location::new((1, 23), (1, 30)), VarInstance("foo", vec![level::Builder::Var("u")])),
                    vec!["u"]
                )
            ))
        );

        assert_eq!(
            line("def x := y.{max 1 2}"),
            Ok(Define(
                (Location::new((1, 5), (1, 6)), "x"),
                None,
                Builder::new(
                    Location::new((1, 10), (1, 21)),
                    VarInstance("y", vec![level::Builder::Max(box level::Builder::Const(1), box level::Builder::Const(2))])
                ),
            ))
        );
    }

    #[test]
    fn successful_import() {
        assert_eq!(line("import "), Ok(Import(vec![])));

        assert_eq!(
            line("import file1 dir/file2"),
            Ok(Import(vec![(Location::new((1, 8), (1, 13)), "file1"), (Location::new((1, 14), (1, 23)), "dir/file2")]))
        );
    }

    #[test]
    fn successful_search() {
        assert_eq!(line("search variable1"), Ok(Search("variable1")));
    }

    #[test]
    fn successful_eval() {
        assert_eq!(line("eval Prop"), Ok(Eval(Builder::new(Location::new((1, 6), (1, 10)), Prop))));
    }

    #[test]
    fn successful_define() {
        assert_eq!(
            line("def x := Prop"),
            Ok(Define((Location::new((1, 5), (1, 6)), "x"), None, Builder::new(Location::new((1, 10), (1, 14)), Prop)))
        );
    }

    #[test]
    fn successful_declare() {
        assert_eq!(
            line("def x.{} := Prop"),
            Ok(Declaration(
                (Location::new((1, 5), (1, 6)), "x"),
                None,
                declaration::Builder::Decl(box Builder::new(Location::new((1, 13), (1, 17)), Prop), vec![])
            ))
        );

        assert_eq!(
            line("def x.{u, v} := Prop"),
            Ok(Declaration(
                (Location::new((1, 5), (1, 6)), "x"),
                None,
                declaration::Builder::Decl(box Builder::new(Location::new((1, 17), (1, 21)), Prop), vec!["u", "v"])
            ))
        );
    }

    #[test]
    fn successful_checktype() {
        assert_eq!(
            line("check Prop : Type"),
            Ok(CheckType(
                Builder::new(Location::new((1, 7), (1, 11)), Prop),
                Builder::new(Location::new((1, 14), (1, 18)), Type(box level::Builder::Const(0)))
            ))
        );
    }

    #[test]
    fn successful_gettype_prop() {
        assert_eq!(line("check Prop"), Ok(GetType(Builder::new(Location::new((1, 7), (1, 11)), Prop))));
    }

    #[test]
    fn successful_gettype_sort() {
        assert_eq!(
            line("check Sort"),
            Ok(GetType(Builder::new(Location::new((1, 7), (1, 11)), Sort(box level::Builder::Const(0)))))
        );
    }

    #[test]
    fn successful_var() {
        assert_eq!(
            line("check fun A: Prop => A"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 23)),
                Abs(
                    "A",
                    Box::new(Builder::new(Location::new((1, 14), (1, 18)), Prop)),
                    Box::new(Builder::new(Location::new((1, 22), (1, 23)), Var("A")))
                )
            )))
        );
    }

    #[test]
    fn successful_type() {
        assert_eq!(
            line("check Type"),
            Ok(GetType(Builder::new(Location::new((1, 7), (1, 11)), Type(box level::Builder::Const(0)))))
        );

        assert_eq!(
            line("check Type 0"),
            Ok(GetType(Builder::new(Location::new((1, 7), (1, 13)), Type(box level::Builder::Const(0)))))
        );

        assert_eq!(
            line("check Type 1"),
            Ok(GetType(Builder::new(Location::new((1, 7), (1, 13)), Type(box level::Builder::Const(1)))))
        );
    }

    #[test]
    fn successful_sort() {
        assert_eq!(
            line("check Sort"),
            Ok(GetType(Builder::new(Location::new((1, 7), (1, 11)), Sort(box level::Builder::Const(0)))))
        );

        assert_eq!(
            line("check Sort 0"),
            Ok(GetType(Builder::new(Location::new((1, 7), (1, 13)), Sort(box level::Builder::Const(0)))))
        );

        assert_eq!(
            line("check Sort 1"),
            Ok(GetType(Builder::new(Location::new((1, 7), (1, 13)), Sort(box level::Builder::Const(1)))))
        );

        assert_eq!(
            line("check Sort (0 + 1)"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 19)),
                Sort(box level::Builder::Plus(box level::Builder::Const(0), 1))
            )))
        );

        assert_eq!(
            line("check Sort (0 + 1 + 2)"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 23)),
                Sort(box level::Builder::Plus(box level::Builder::Plus(box level::Builder::Const(0), 1), 2))
            )))
        );

        assert_eq!(
            line("check Sort max 0 0"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 19)),
                Sort(box level::Builder::Max(box level::Builder::Const(0), box level::Builder::Const(0)))
            )))
        );

        assert_eq!(
            line("check Sort imax 0 0"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 20)),
                Sort(box level::Builder::IMax(box level::Builder::Const(0), box level::Builder::Const(0)))
            )))
        );
    }

    #[test]
    fn cannot_transform_sort_level() {
        assert_eq!(
            line("check Sort 10000000000000000000000"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 12), (1, 35)),
            })
        );

        assert_eq!(
            line("check Sort (10000000000000000000000 + 0)"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 13), (1, 36)),
            })
        );

        assert_eq!(
            line("check Sort (0 + 10000000000000000000000)"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 17), (1, 40)),
            })
        );

        assert_eq!(
            line("check Sort max 0 10000000000000000000000"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 18), (1, 41)),
            })
        );

        assert_eq!(
            line("check Sort max 10000000000000000000000 0"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 16), (1, 39)),
            })
        );

        assert_eq!(
            line("check Sort imax 0 10000000000000000000000"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 19), (1, 42)),
            })
        );

        assert_eq!(
            line("check Sort imax 10000000000000000000000 0"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 17), (1, 40)),
            })
        );
    }

    #[test]
    fn cannot_transform_sort_term() {
        // VarDecl
        assert_eq!(
            line("check foo.{10000000000000000000000}"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 12), (1, 35)),
            })
        );

        // Type
        assert_eq!(
            line("check (x: Type 10000000000000000000000) -> x"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 16), (1, 39)),
            })
        );

        // App
        assert_eq!(
            line("check ((x: Type 10000000000000000000000) -> x) A"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 17), (1, 40)),
            })
        );

        // Abs
        assert_eq!(
            line("check fun x: Prop => (x: Type 10000000000000000000000) -> x"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 31), (1, 54)),
            })
        );

        // dProd
        assert_eq!(
            line("check (x: Type) -> (y: Sort 10000000000000000000000) -> x"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 29), (1, 52)),
            })
        );

        // Prod
        assert_eq!(
            line("check Prop -> Sort 10000000000000000000000"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 20), (1, 43)),
            })
        );
    }

    #[test]
    fn cannot_transform_sort_expr() {
        // CheckType
        assert_eq!(
            line("check Sort 10000000000000000000000 : Type"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 12), (1, 35)),
            })
        );

        assert_eq!(
            line("check Type : Sort 10000000000000000000000"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 19), (1, 42)),
            })
        );

        // Define
        assert_eq!(
            line("def x := Sort 10000000000000000000000"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 15), (1, 38)),
            })
        );

        // DefineCheckType
        assert_eq!(
            line("def x : Sort imax 10000000000000000000000 0 := Prop"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 19), (1, 42)),
            })
        );

        assert_eq!(
            line("def x : Type := Sort 10000000000000000000000"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 22), (1, 45)),
            })
        );

        // Declaration
        assert_eq!(
            line("def x.{u} := Sort 10000000000000000000000"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 19), (1, 42)),
            })
        );

        // DeclarationCheckType
        assert_eq!(
            line("def x.{u} : Sort 10000000000000000000000 := Prop"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 18), (1, 41)),
            })
        );

        assert_eq!(
            line("def x.{u} : Type := Sort 10000000000000000000000"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 26), (1, 49)),
            })
        );

        // Eval
        assert_eq!(
            line("eval Prop -> Sort 10000000000000000000000"),
            Err(Error {
                kind: Kind::TransformError(TOO_LARGE_NUMBER.to_owned()),
                location: Location::new((1, 19), (1, 42)),
            })
        );
    }

    #[test]
    fn successful_app() {
        assert_eq!(
            line("check A B C"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 12)),
                App(
                    Box::new(Builder::new(
                        Location::new((1, 7), (1, 12)),
                        App(
                            Box::new(Builder::new(Location::new((1, 7), (1, 8)), Var("A"))),
                            Box::new(Builder::new(Location::new((1, 9), (1, 10)), Var("B"))),
                        ),
                    )),
                    Box::new(Builder::new(Location::new((1, 11), (1, 12)), Var("C"))),
                ),
            )))
        );

        assert_eq!(
            line("check (A B) C"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 14)),
                App(
                    Box::new(Builder::new(
                        Location::new((1, 8), (1, 11)),
                        App(
                            Box::new(Builder::new(Location::new((1, 8), (1, 9)), Var("A"))),
                            Box::new(Builder::new(Location::new((1, 10), (1, 11)), Var("B"))),
                        ),
                    )),
                    Box::new(Builder::new(Location::new((1, 13), (1, 14)), Var("C"))),
                ),
            )))
        );

        assert_eq!(
            line("check A (B C)"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 14)),
                App(
                    Box::new(Builder::new(Location::new((1, 7), (1, 8)), Var("A"))),
                    Box::new(Builder::new(
                        Location::new((1, 10), (1, 13)),
                        App(
                            Box::new(Builder::new(Location::new((1, 10), (1, 11)), Var("B"))),
                            Box::new(Builder::new(Location::new((1, 12), (1, 13)), Var("C"))),
                        ),
                    )),
                ),
            )))
        );
    }

    #[test]
    fn successful_prod() {
        assert_eq!(
            line("check A -> B -> C"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 18)),
                Prod(
                    "_",
                    Box::new(Builder::new(Location::new((1, 7), (1, 8)), Var("A"))),
                    Box::new(Builder::new(
                        Location::new((1, 7), (1, 18)),
                        Prod(
                            "_",
                            Box::new(Builder::new(Location::new((1, 12), (1, 13)), Var("B"))),
                            Box::new(Builder::new(Location::new((1, 17), (1, 18)), Var("C"))),
                        ),
                    )),
                ),
            )))
        );

        assert_eq!(
            line("check A -> (B -> C)"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 20)),
                Prod(
                    "_",
                    Box::new(Builder::new(Location::new((1, 7), (1, 8)), Var("A"))),
                    Box::new(Builder::new(
                        Location::new((1, 13), (1, 19)),
                        Prod(
                            "_",
                            Box::new(Builder::new(Location::new((1, 13), (1, 14)), Var("B"))),
                            Box::new(Builder::new(Location::new((1, 18), (1, 19)), Var("C"))),
                        ),
                    )),
                ),
            )))
        );

        assert_eq!(
            line("check (A -> B) -> C"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 20)),
                Prod(
                    "_",
                    Box::new(Builder::new(
                        Location::new((1, 8), (1, 14)),
                        Prod(
                            "_",
                            Box::new(Builder::new(Location::new((1, 8), (1, 9)), Var("A"))),
                            Box::new(Builder::new(Location::new((1, 13), (1, 14)), Var("B"))),
                        ),
                    )),
                    Box::new(Builder::new(Location::new((1, 19), (1, 20)), Var("C"))),
                ),
            )))
        );
    }

    #[test]
    fn successful_dprod() {
        assert_eq!(
            line("check (x: Type) -> (y: Type 1) -> x"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 36)),
                Prod(
                    "x",
                    Box::new(Builder::new(Location::new((1, 11), (1, 15)), Type(box level::Builder::Const(0)))),
                    Box::new(Builder::new(
                        Location::new((1, 20), (1, 36)),
                        Prod(
                            "y",
                            Box::new(Builder::new(Location::new((1, 24), (1, 30)), Type(box level::Builder::Const(1)))),
                            Box::new(Builder::new(Location::new((1, 35), (1, 36)), Var("x"))),
                        ),
                    )),
                ),
            )))
        );

        assert_eq!(
            line("check (x: Type) -> ((y: Type 1) -> x)"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 38)),
                Prod(
                    "x",
                    Box::new(Builder::new(Location::new((1, 11), (1, 15)), Type(box level::Builder::Const(0)))),
                    Box::new(Builder::new(
                        Location::new((1, 21), (1, 37)),
                        Prod(
                            "y",
                            Box::new(Builder::new(Location::new((1, 25), (1, 31)), Type(box level::Builder::Const(1)))),
                            Box::new(Builder::new(Location::new((1, 36), (1, 37)), Var("x"))),
                        ),
                    )),
                ),
            )))
        );
    }

    #[test]
    fn successful_abs() {
        assert_eq!(
            line("check fun w x: Prop, y z: Prop => x"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 36)),
                Abs(
                    "w",
                    Box::new(Builder::new(Location::new((1, 16), (1, 20)), Prop)),
                    Box::new(Builder::new(
                        Location::new((1, 7), (1, 36)),
                        Abs(
                            "x",
                            Box::new(Builder::new(Location::new((1, 16), (1, 20)), Prop)),
                            Box::new(Builder::new(
                                Location::new((1, 7), (1, 36)),
                                Abs(
                                    "y",
                                    Box::new(Builder::new(Location::new((1, 27), (1, 31)), Prop)),
                                    Box::new(Builder::new(
                                        Location::new((1, 7), (1, 36)),
                                        Abs(
                                            "z",
                                            Box::new(Builder::new(Location::new((1, 27), (1, 31)), Prop)),
                                            Box::new(Builder::new(Location::new((1, 35), (1, 36)), Var("x"))),
                                        ),
                                    )),
                                ),
                            )),
                        ),
                    )),
                )
            )))
        );
    }

    #[test]
    fn failed_dprod() {
        assert_eq!(
            line("check (x:A)"),
            Err(Error {
                kind: Kind::UnexpectedToken(SIMPLE_TERM_ERR.to_owned()),
                location: Location::new((1, 7), (1, 12)),
            })
        );
        assert_eq!(
            line("check (x:A) -> (y:B)"),
            Err(Error {
                kind: Kind::UnexpectedToken(SIMPLE_TERM_ERR.to_owned()),
                location: Location::new((1, 16), (1, 21)),
            })
        );
    }

    #[test]
    fn context_for_abs_args() {
        assert_eq!(
            line("check fun x : Prop, x : x, x : x => x"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 38)),
                Abs(
                    "x",
                    Box::new(Builder::new(Location::new((1, 15), (1, 19)), Prop)),
                    Box::new(Builder::new(
                        Location::new((1, 7), (1, 38)),
                        Abs(
                            "x",
                            Box::new(Builder::new(Location::new((1, 25), (1, 26)), Var("x"))),
                            Box::new(Builder::new(
                                Location::new((1, 7), (1, 38)),
                                Abs(
                                    "x",
                                    Box::new(Builder::new(Location::new((1, 32), (1, 33)), Var("x"))),
                                    Box::new(Builder::new(Location::new((1, 37), (1, 38)), Var("x"))),
                                ),
                            )),
                        ),
                    )),
                ),
            )))
        );

        assert_eq!(
            line("check fun x : Prop, x x : x => x"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 33)),
                Abs(
                    "x",
                    Box::new(Builder::new(Location::new((1, 15), (1, 19)), Prop)),
                    Box::new(Builder::new(
                        Location::new((1, 7), (1, 33)),
                        Abs(
                            "x",
                            Box::new(Builder::new(Location::new((1, 27), (1, 28)), Var("x"))),
                            Box::new(Builder::new(
                                Location::new((1, 7), (1, 33)),
                                Abs(
                                    "x",
                                    Box::new(Builder::new(Location::new((1, 27), (1, 28)), Var("x"))),
                                    Box::new(Builder::new(Location::new((1, 32), (1, 33)), Var("x"))),
                                ),
                            )),
                        ),
                    )),
                ),
            )))
        );

        assert_eq!(
            line("check fun x : Prop, y z : x => z"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 33)),
                Abs(
                    "x",
                    Box::new(Builder::new(Location::new((1, 15), (1, 19)), Prop)),
                    Box::new(Builder::new(
                        Location::new((1, 7), (1, 33)),
                        Abs(
                            "y",
                            Box::new(Builder::new(Location::new((1, 27), (1, 28)), Var("x"))),
                            Box::new(Builder::new(
                                Location::new((1, 7), (1, 33)),
                                Abs(
                                    "z",
                                    Box::new(Builder::new(Location::new((1, 27), (1, 28)), Var("x"))),
                                    Box::new(Builder::new(Location::new((1, 32), (1, 33)), Var("z")))
                                )
                            )),
                        )
                    ))
                )
            )))
        );
    }

    #[test]
    fn context_for_dprod_args() {
        assert_eq!(
            line("check (x : Prop, x : x, x : x) -> x"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 36)),
                Prod(
                    "x",
                    Box::new(Builder::new(Location::new((1, 12), (1, 16)), Prop)),
                    Box::new(Builder::new(
                        Location::new((1, 7), (1, 36)),
                        Prod(
                            "x",
                            Box::new(Builder::new(Location::new((1, 22), (1, 23)), Var("x"))),
                            Box::new(Builder::new(
                                Location::new((1, 7), (1, 36)),
                                Prod(
                                    "x",
                                    Box::new(Builder::new(Location::new((1, 29), (1, 30)), Var("x"))),
                                    Box::new(Builder::new(Location::new((1, 35), (1, 36)), Var("x"))),
                                ),
                            )),
                        ),
                    )),
                ),
            )))
        );

        assert_eq!(
            line("check (x : Prop, x x : x) -> x"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 31)),
                Prod(
                    "x",
                    Box::new(Builder::new(Location::new((1, 12), (1, 16)), Prop)),
                    Box::new(Builder::new(
                        Location::new((1, 7), (1, 31)),
                        Prod(
                            "x",
                            Box::new(Builder::new(Location::new((1, 24), (1, 25)), Var("x"))),
                            Box::new(Builder::new(
                                Location::new((1, 7), (1, 31)),
                                Prod(
                                    "x",
                                    Box::new(Builder::new(Location::new((1, 24), (1, 25)), Var("x"))),
                                    Box::new(Builder::new(Location::new((1, 30), (1, 31)), Var("x"))),
                                ),
                            )),
                        ),
                    )),
                ),
            )))
        );

        assert_eq!(
            line("check (x : Prop, y z : x) -> z"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 31)),
                Prod(
                    "x",
                    Box::new(Builder::new(Location::new((1, 12), (1, 16)), Prop)),
                    Box::new(Builder::new(
                        Location::new((1, 7), (1, 31)),
                        Prod(
                            "y",
                            Box::new(Builder::new(Location::new((1, 24), (1, 25)), Var("x"))),
                            Box::new(Builder::new(
                                Location::new((1, 7), (1, 31)),
                                Prod(
                                    "z",
                                    Box::new(Builder::new(Location::new((1, 24), (1, 25)), Var("x"))),
                                    Box::new(Builder::new(Location::new((1, 30), (1, 31)), Var("z")))
                                )
                            )),
                        )
                    ))
                )
            )))
        );
    }

    #[test]
    fn parenthesis_in_abs() {
        assert_eq!(
            line("check fun (((w x : Prop))), y z : Prop => x"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 44)),
                Abs(
                    "w",
                    Box::new(Builder::new(Location::new((1, 20), (1, 24)), Prop)),
                    Box::new(Builder::new(
                        Location::new((1, 7), (1, 44)),
                        Abs(
                            "x",
                            Box::new(Builder::new(Location::new((1, 20), (1, 24)), Prop)),
                            Box::new(Builder::new(
                                Location::new((1, 7), (1, 44)),
                                Abs(
                                    "y",
                                    Box::new(Builder::new(Location::new((1, 35), (1, 39)), Prop)),
                                    Box::new(Builder::new(
                                        Location::new((1, 7), (1, 44)),
                                        Abs(
                                            "z",
                                            Box::new(Builder::new(Location::new((1, 35), (1, 39)), Prop)),
                                            Box::new(Builder::new(Location::new((1, 43), (1, 44)), Var("x"))),
                                        ),
                                    )),
                                ),
                            )),
                        ),
                    )),
                ),
            )))
        );
    }

    #[test]
    fn parenthesis_in_prod() {
        assert_eq!(
            line("check (((Type))) -> (((Type 1 -> Type 2)))"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 43)),
                Prod(
                    "_",
                    Box::new(Builder::new(Location::new((1, 10), (1, 14)), Type(box level::Builder::Const(0)))),
                    Box::new(Builder::new(
                        Location::new((1, 24), (1, 40)),
                        Prod(
                            "_",
                            Box::new(Builder::new(Location::new((1, 24), (1, 30)), Type(box level::Builder::Const(1)))),
                            Box::new(Builder::new(Location::new((1, 34), (1, 40)), Type(box level::Builder::Const(2))))
                        )
                    )),
                )
            )))
        );
    }

    #[test]
    fn parenthesis_in_dprod() {
        assert_eq!(
            line("check (((x:Type))) -> ((((y:Type 1) -> x)))"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 44)),
                Prod(
                    "x",
                    Box::new(Builder::new(Location::new((1, 12), (1, 16)), Type(box level::Builder::Const(0)))),
                    Box::new(Builder::new(
                        Location::new((1, 26), (1, 41)),
                        Prod(
                            "y",
                            Box::new(Builder::new(Location::new((1, 29), (1, 35)), Type(box level::Builder::Const(1)))),
                            Box::new(Builder::new(Location::new((1, 40), (1, 41)), Var("x")))
                        )
                    ),)
                )
            )))
        );
    }

    #[test]
    fn parenthesis_in_app() {
        assert_eq!(
            line("check ((((((A))) (((B C))))))"),
            Ok(GetType(Builder::new(
                Location::new((1, 10), (1, 27)),
                App(
                    Box::new(Builder::new(Location::new((1, 13), (1, 14)), Var("A"))),
                    Box::new(Builder::new(
                        Location::new((1, 21), (1, 24)),
                        App(
                            Box::new(Builder::new(Location::new((1, 21), (1, 22)), Var("B"))),
                            Box::new(Builder::new(Location::new((1, 23), (1, 24)), Var("C")))
                        )
                    ))
                )
            )))
        );
    }

    #[test]
    fn successful_parsers() {
        let input = r#"
            def x := Prop -> Prop

            // this is a comment
            check fun x:Prop => x
        "#;

        // Since the location will differ, we just check that the kind is correct by displaying output
        assert_eq!(format!("{}", file(input).unwrap()[0]), format!("{}", line("def x := Prop -> Prop").unwrap()));
        assert_eq!(format!("{}", file(input).unwrap()[1]), format!("{}", line("check fun x:Prop => x").unwrap()));
    }

    #[test]
    fn successful_convert_error() {
        assert_eq!(
            line("chehk 2x"),
            Err(Error {
                kind: Kind::UnexpectedToken(COMMAND_ERR.to_owned()),
                location: Location::new((1, 1), (1, 6)),
            })
        );
        assert_eq!(
            line("check 2x"),
            Err(Error {
                kind: Kind::UnexpectedToken(TERM_ERR.to_owned()),
                location: Location::new((1, 7), (1, 9)),
            })
        );
        assert_eq!(
            line("check x:"),
            Err(Error {
                kind: Kind::UnexpectedToken(TERM_ERR.to_owned()),
                location: Location::new((1, 9), (1, 10)),
            })
        );
    }

    #[test]
    fn failed_parsers() {
        assert_eq!(
            file(
                "def x : Type := Prop -> Prop
                 // this is a comment
                        check .x"
            ),
            Err(Error {
                kind: Kind::UnexpectedToken(TERM_ERR.to_owned()),
                location: Location::new((3, 31), (3, 33)),
            })
        );
    }

    #[test]
    fn successful_abs_wildcard() {
        assert_eq!(
            line("check fun _:Prop => Prop"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 25)),
                Abs(
                    "_",
                    Box::new(Builder::new(Location::new((1, 13), (1, 17)), Prop)),
                    Box::new(Builder::new(Location::new((1, 21), (1, 25)), Prop))
                )
            )))
        );
    }

    #[test]
    fn successful_prod_wildcard() {
        assert_eq!(
            line("check (_:Prop) -> Prop"),
            Ok(GetType(Builder::new(
                Location::new((1, 7), (1, 23)),
                Prod(
                    "_",
                    Box::new(Builder::new(Location::new((1, 10), (1, 14)), Prop)),
                    Box::new(Builder::new(Location::new((1, 19), (1, 23)), Prop))
                )
            )))
        );
    }
}
